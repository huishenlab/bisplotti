#' Plot the results of tabulateEpibed() as a quasi-lollipop plot.
#'
#' NOTE: If you run tabulateEpibed() in NOMe mode with include_empty_reads = TRUE,
#' then it is highly suggested you run plotEpibed() with show_all_points = TRUE also.
#' If not, it is possible that reads in the CG and GC plots will not line up, depending
#' on if there are empty reads in one plot, but not the other.
#'
#' @param mat Input matrix that comes out of tabulateEpibed()
#' @param plot_read_avg Whether to also plot the average methylation state (default: TRUE)
#' @param show_readnames Whether to show the read names (default: TRUE)
#' @param show_positions Whether to show the genomic positions (default: TRUE)
#' @param show_all_points Whether to show all points (i.e., empty reads, unknown, and filtered sites) (default: FALSE)
#' @param meth_color What color should the methylated states be (default: '#FF2400')
#' @param unmeth_color What color should the unmethylated states be (default: '#6495ED')
#' @param na_color What color should the NA values be (default: 'grey')
#' @param size What size the points should be drawn as (default: 6)
#'
#' @return An epibed ggplot object or list of ggplot objects if plot_read_avg is TRUE
#'
#' @import ggplot2
#' @importFrom reshape2 melt
#'
#' @export
#'
#' @examples
#'
#' epibed.nome <- system.file("extdata", "hct116.nome.epibed.gz",
#'                            package="biscuiteer")
#' epibed.nome.gr <- readEpibed(epibed = epibed.nome, is.nome = TRUE,
#'                              genome = "hg19", chr = "chr1")
#' epibed.tab.nome <- tabulateEpibed(epibed.nome.gr)
#' plotEpibed(epibed.tab.nome$gc_table)
#'
plotEpibed <- function(mat,
                        plot_read_avg = TRUE,
                        show_readnames = TRUE,
                        show_positions = TRUE,
                        show_all_points = FALSE,
                        meth_color = "#FF2400",
                        unmeth_color = "#6495ED",
                        na_color = "grey",
                        size = 6) {

    # check if input is a matrix
    if (is.list(mat) & is(mat[[1]], "matrix")) {
        message("Input given is likely the output of tabulateEpibed() in NOMe mode.")
        stop("Please select either $cg_table, $gc_table, or $vr_table to plot.")
    }
    if (!is.list(mat) & !is(mat, "matrix")) {
        stop("Input needs to be a matrix generated by tabulateEpibed()")
    }

    # If running in NOMe mode and include_empty_reads = TRUE in tabulateEpibed, then the reads in the CG and GC plots
    # may not line up. To ensure alignment, it's best to set show_all_points = TRUE in this instance.
    mat.melt <- .makePlotData(mat, show_all_points)

    # plot epibed
    ql_theme <- .set_ql_theme(show_readnames, show_positions)
    plt <- .epiClustPlot(mat.melt, ql_theme, meth_color, unmeth_color, na_color, size)

    # average methylation
    # FIXME: If having SNP plot separate, find way to avoid making average plot for SNPs
    if (plot_read_avg) {
        plt_avg <- .plotAvg(mat, meth_color, unmeth_color, ql_theme, size)
        return(list(epistate=plt,
                    meth_avg=plt_avg))
    } else {
        return(plt)
    }
}

# helper to make the melted dataset for plotting
.makePlotData <- function(mat, show_all_points) {
    # auto-detect input type
    is.cg = FALSE
    is.gc = FALSE
    is.vr = FALSE
    if(any(mat %in% c("M", "U"))) is.cg = TRUE
    if(any(mat %in% c("S", "O"))) is.gc = TRUE
    if(any(mat %in% c("A", "C", "T", "G", "R", "Y"))) is.vr = TRUE

    # break if both are FALSE
    if (isFALSE(is.cg) & isFALSE(is.gc) & isFALSE(is.vr)) {
        message("Don't know what to do with input.")
        stop("Please run tabulateEpibed() first to produce input for this function.")
    }

    # cast to a 'melted' data frame
    mat.melt <- reshape2::melt(mat, id.vars = rownames(mat))
    if (!show_all_points) {
        mat.melt <- subset(mat.melt, !is.na(value))
    }

    return(mat.melt)
}

# helper to calculate avg methylation of a region and plot it
.plotAvg <- function(mat, meth_color, unmeth_color, theme, size) {
    # check if input is a matrix
    if (!is(mat, "matrix")) {
        stop("Input needs to be a matrix")
    }

    mat[mat %in% c("M", "O")] <- 1
    mat[mat %in% c("U", "S")] <- 0
    mat[mat %in% c("A", "T", "G", "C")] <- -1

    mat <- apply(mat, 2, as.numeric)
    mat.meth.avg <- data.frame(avg_meth = colMeans(mat, na.rm = TRUE))
    mat.meth.avg <- na.omit(mat.meth.avg) # remove empty rows that are somehow making it all the way here
    mat.meth.avg$avg_meth <- ifelse(mat.meth.avg$avg_meth < 0, NA, mat.meth.avg$avg_meth)

    mat.meth.avg$position <- rownames(mat.meth.avg)
    mat.meth.avg$y <- ifelse(is.na(mat.meth.avg$avg_meth), "SNP status", "Average methylation status")

    plt_avg <- ggplot(mat.meth.avg, aes(x = position, y = y)) +
        geom_point(aes(fill = avg_meth), size=size, pch=21, color="black", na.rm=TRUE) +
        scale_fill_gradient(low = unmeth_color, high = meth_color, limits = c(0,1)) +
        scale_x_discrete(name ="", limits=rownames(mat.meth.avg)) +
        scale_y_discrete(limits = c("Average methylation status")) +
        guides(color = "legend") +
        theme

    return(plt_avg)
}

# helper to set the ql theme depending on readnames and position toggles
.set_ql_theme <- function(show_readnames = TRUE, show_positions = TRUE) {
    ql_theme <- theme_bw(12) +
        theme(
            axis.title = element_blank(),
            legend.title = element_blank(),
            axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
            panel.grid.major.x = element_blank(),
            panel.grid.major.y = element_line(color = "black")
        )

    if (!show_readnames) {
        # set the theme
        ql_theme <- ql_theme +
            theme(
                axis.text.y = element_blank(),
                axis.ticks.y = element_blank()
            )
    }

    if (!show_positions) {
        ql_theme <- ql_theme +
            theme(
                axis.text.x = element_blank(),
                axis.ticks.x = element_blank()
            )
    }

    return(ql_theme)
}

# helper to plot epibeds given a matrix of read, pos, value
# TODO: Remove default options as this is a non-exported function
#       Will need to then define these values for the .epiClustPlot call in the epistateCaller function
.epiClustPlot <- function(matplotdata,
                          ql_theme,
                          meth_color = "#FF2400",
                          unmeth_color = "#6495ED",
                          na_color = "grey",
                          size = 6) {

    # combine all combinations of letters
    #apply(expand.grid(c("A", "B", "C"), c("M", "U"), c("A", "B", "C")), 1, paste, collapse="")

    snp_list <- c("A", "T", "G", "C", "R", "Y")

    plt <- ggplot(matplotdata, aes(x = Var2, y = Var1)) +
        geom_point(aes(fill = value), size=size, pch=21, color="black") +
        guides(color = "legend") +
        geom_label(data = subset(matplotdata, value %in% snp_list), aes(label = value)) +
        ql_theme

    if (any(matplotdata$value %in% c("M", "U"))) {
        plt <- plt +
            scale_fill_manual(values = c(M = meth_color, U = unmeth_color), na.value = na_color)
    } else {
        plt <- plt +
            scale_fill_manual(values = c(O = meth_color, S = unmeth_color), na.value = na_color)
    }

    return(plt)
}

#' Calculate and plot a hierarchical clustering of the epibeds
#'
#' WARNING: This is a beta function and should not be used for publication level analyses!!!!
#'
#' @param mat Input matrix that comes out of tabulateEpibed()
#' @param stringdist_method stringdist::stringdist algorithm to use (default: "hamming")
#' @param hclust_method Clustering algorithm to use (default: "ward.D2")
#' @param plot Whether to plot the clustered epibeds (default: TRUE)
#'
#' @return A hierarchical cluster (hclust) object
#'
#' @import ggtree
#' @importFrom stringdist stringdist
#' @importFrom cowplot plot_grid
#'
#' @examples
#'
#' #epibed.nome <- system.file("extdata", "hct116.nome.epibed.gz",
#' #                           package="biscuiteer")
#' #epibed.nome.gr <- readEpibed(epibed = epibed.nome, is.nome = TRUE,
#' #                             genome = "hg19", chr = "chr1")
#' #epibed.tab.nome <- tabulateEpibed(epibed.nome.gr)
#' #epistateCaller(epibed.tab.nome)
#'
epistateCaller <- function(mat,
                           stringdist_method="hamming",
                           hclust_method="ward.D2",
                           plot = TRUE) {
    # check for both cg and gc tables
    if (is.list(mat)) {
        stopifnot(exists("cg_table", where = mat) & exists("gc_table", where = mat))

        mat.merge <- merge(mat$cg_table, mat$gc_table, by = 0)
        row.names(mat.merge) <- mat.merge[, 1]
        mat.merge <- mat.merge[-1]
    } else {
        mat.merge <- mat
    }

    mat.merge[is.na(mat.merge) |
              mat.merge == "A" | mat.merge == "T" |
              mat.merge == "G" | mat.merge == "C" |
              mat.merge == "U" | mat.merge == "S"] <- 0
    mat.merge[mat.merge == "M" | mat.merge == "O"] <- 1

    epistates <- apply(mat.merge, 1, paste0, collapse = "")
    hamming <- outer(epistates, epistates, stringdist, method = stringdist_method)

    hcluster <- hclust(as.dist(hamming), method = hclust_method)
    if (!plot) {
        return(hcluster)
    }

    if (!is.list(mat)) {
        matplotdata <- list(.makePlotData(mat, show_all_points = FALSE))
    } else {
        matplotdata <- lapply(
            mat, function(meth_table) { .makePlotData(meth_table, show_all_points = FALSE) }
        )
    }

    tree <- ggtree(as.dendrogram(hcluster), branch.length = "none")

    ql_theme <- .set_ql_theme(TRUE, TRUE)

    plots <- lapply(
        matplotdata,
        function(m) {
            m$Var1 <- factor(m$Var1, levels = rev(get_taxa_name(tree)))
            plt <- .epiClustPlot(m, ql_theme)

            clust_plot <- plot_grid(
                tree, NULL, plt,
                rel_widths = c(1, -0.05, 2), nrow = 1, align = 'h'
            )
            return(clust_plot)
        }
    )

    return(plots)
}
